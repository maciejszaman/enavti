# Server Documentation GENERATED BY AI DLA BARTKA

## Overview

This is the Socket.IO game server for enavti - a multiplayer quiz game. Players join lobbies, answer questions, and compete in real-time.

## Architecture

```
Express HTTP Server
    ↓
Socket.IO WebSocket Server
    ↓
In-Memory Lobby Storage (Map)
    ↓
Game State Management
```

---

## Data Structures

All types are defined in `packages/sharedTypes/src/index.ts` and shared between client and server.

### Lobby

The main game room containing players and game state.

```typescript
interface Lobby {
  id: string; // 6-character lobby code (e.g., "A3F9K2")
  players: Player[]; // Array of connected players
  createdAt: Date; // When lobby was created
  gameState: GameState; // Current phase: "lobby" | "roundOne" | "roundTwo" | "roundThree" | "ended" | null

  // Round One specific properties
  activeQuestion?: {
    questionId: number; // ID from questions.json
    text: string; // Question text
    answer: string; // Correct answer
    targetPlayer: string; // Socket ID of player who must answer
    askedAt: Date; // When question was asked
    timeoutId?: NodeJS.Timeout; // Timer interval ID (for cleanup)
  };
  roundOneQuestions?: Question[]; // Shuffled questions for this round
  currentQuestionIndex?: number; // Which question we're on (0-based)
}
```

**Important:** `activeQuestion` is deleted when:

- Player answers (correct or wrong)
- Timer runs out
- Moving to next question

### Player

Individual participant in a lobby.

```typescript
interface Player {
  id: string; // Socket ID (unique per connection)
  name: string; // Display name chosen by player
  character?: {
    // Avatar selection
    character: number; // Character type (0-5)
    clothesColor: number; // Color variant (0-5)
  };
  lives?: number; // Lives remaining (starts at 3, game property)
  score?: number; // Points earned (game property)
}
```

### Question

Loaded from `questions.json`.

```typescript
interface Question {
  id: number; // Unique identifier
  question: string; // Question text
  answer: string; // Correct answer
  multiple_choice: boolean; // Future feature flag (not used yet)
}
```

### TimerUpdate

Sent to clients every 100ms during countdown.

```typescript
interface TimerUpdate {
  timeRemaining: number; // Milliseconds left (3000 → 0)
  totalTime: number; // Total duration (3000ms)
  targetPlayer: string; // Socket ID of who should answer
}
```

### Announcement

Messages shown to players.

```typescript
interface Announcement {
  type: AnnouncementType; // "info" | "question" | "game-start" | "modal" | etc.
  message: string | ModalType; // Text to display or modal type
  duration: number; // How long to show (milliseconds)
  targetPlayer?: string; // Optional: highlight specific player
  gameState?: GameState; // Optional: game phase context
  shuffledOrder?: Player[]; // Optional: for shuffle modal
}
```

### ChatMessage

Player messages (also used for answers).

```typescript
interface ChatMessage {
  playerId: string; // Socket ID
  playerName: string; // Display name
  message: string; // Message content
  timestamp: number; // Unix timestamp
  visible?: boolean; // Client-side flag for animations
}
```

---

## Code Structure

### 1. Server Setup (Lines 1-75)

**What it does:**

- Sets up Express + Socket.IO server
- Enables CORS for client connections
- Creates in-memory storage for lobbies

**Key Components:**

- `lobbies` - Map storing all active game lobbies
- `generateLobbyId()` - Creates random 6-character lobby codes (e.g., "A3F9K2")

**REST Endpoints:**

- `GET /health` - Health check
- `GET /lobbies` - List all active lobbies
- `GET /api/lobby/:lobbyId` - Check if lobby exists
- `POST /createLobby` - Create new lobby, returns lobby ID

---

### 2. Socket Event Handlers (Lines 77-240)

#### `connection` (Line 77)

When a player connects to the server

#### `lobby-update-req` (Line 80)

**What it does:** Sends current lobby state to requesting player
**Emits:** `lobby-update` with players and game state

#### `join-lobby` (Line 93)

**What it does:** Adds player to a lobby
**Receives:** `{ lobbyId, playerName, character }`
**Emits:** `lobby-update` to all players in lobby

#### `disconnect` (Line 131)

**What it does:** Removes player from lobby when they leave
**Side effects:** Deletes empty lobbies

#### `chat-message-req` (Line 155)

**What it does:** Handles player messages AND answer checking
**Logic:**

- If message is from target player during active question → check answer
- If answer correct → award points
- If answer wrong → lose life
- Otherwise → broadcast as normal chat message

**Important:** This handles the answer-during-announcement edge case (Line 165-168)

#### `start-game` (Line 245)

**What it does:** Starts Round One when lobby host clicks "Start"
**Flow:**

1. Reset all player lives to 3
2. Show "Game starting" announcement
3. Shuffle player order (modal animation)
4. Prepare questions
5. Start asking questions

---

### 3. Game Logic Functions

#### `prepareRoundOneQuestions()` (Line 313)

**What it does:** Loads questions from `questions.json` and shuffles them
**Returns:** Array of questions (2 per player)

#### `playRoundOne()` (Line 335)

**What it does:** Kicks off the question-asking process
**Calls:** `askNextQuestion()`

#### `continueRoundOne()` (Line 353)

**What it does:** Moves to next question or ends round
**Logic:**

- Increments question index
- Checks if all questions answered
- Sends timer reset before next question

#### `askNextQuestion()` (Line 396)

**What it does:** Shows question announcement and schedules timer
**Flow:**

1. Get current question and target player
2. Store as `lobby.activeQuestion`
3. Emit question announcement with calculated duration
4. Wait for announcement to finish
5. **Check if still active** (player might have answered early)
6. Start answer timer if still waiting

**Duration Formula:**

```typescript
const duration = question.split(" ").length * 500 + 1000;
// Example: 5 words = 3500ms (5 * 500 + 1000)
```

**Bug Fix (Line 436-439):** Prevents timer from starting if player answered during announcement

---

### 4. Timer System

#### `startAnswerTimer()` (Line 444)

**What it does:** Starts 3-second countdown timer for answering
**How it works:**

- Runs `setInterval` every 100ms
- Decrements `timeRemaining` by 100ms each tick
- Emits `timer-update` to all clients (but only target player sees it)
- Calls `handleTimeout()` when time expires

**Important Details:**

- **Tick Interval:** 100ms (10 updates per second)
- **Total Duration:** 3000ms (3 seconds)
- **Client Updates:** 30 total emissions per question
- **Performance:** Negligible - only 1 player affected at a time

**Timer Colors:**

- White: > 1.5s remaining
- Amber: 1.0s - 1.5s
- Red: < 1.0s

**Stored:** `lobby.activeQuestion.timeoutId` for cleanup

#### `handleTimeout()` (Line 462)

**What it does:** Handles when timer reaches zero
**Flow:**

1. Send timer reset events
2. Player loses a life
3. Show timeout announcement with correct answer
4. Delete active question
5. Continue to next question after 4 seconds

---

## Data Flow Examples

### Normal Question Flow

```
askNextQuestion()
    ↓
Emit announcement (3.5s)
    ↓
Wait 3.5s
    ↓
Check question still active ✓
    ↓
startAnswerTimer()
    ↓
Emit timer-update (every 100ms)
    ↓
Player answers OR timeout
    ↓
continueRoundOne()
```

### Early Answer Flow (During Announcement)

```
askNextQuestion()
    ↓
Emit announcement (3.5s)
    ↓
[Player answers at 1s]
    ↓
chat-message-req handler
    ↓
Check answer
    ↓
delete lobby.activeQuestion
    ↓
continueRoundOne()
    ↓
[Original wait completes at 3.5s]
    ↓
Check question still active ✗
    ↓
Return early (no timer started)
```

---

## Socket Events Reference

### Server Emits (to clients)

| Event                    | Data                                           | When                                   |
| ------------------------ | ---------------------------------------------- | -------------------------------------- |
| `lobby-update`           | `{ players, gameState }`                       | Players join/leave, game state changes |
| `announcement`           | `{ type, message, duration, targetPlayer? }`   | Questions, results, game events        |
| `timer-update`           | `{ timeRemaining, totalTime, targetPlayer }`   | Every 100ms during countdown           |
| `timer-stop`             | none                                           | Answer submitted or timeout            |
| `chat-message-broadcast` | `{ playerId, playerName, message, timestamp }` | Player sends chat                      |
| `error`                  | `{ message }`                                  | Errors occur                           |

### Server Listens (from clients)

| Event              | Data                                 | Purpose                     |
| ------------------ | ------------------------------------ | --------------------------- |
| `lobby-update-req` | `{ lobbyId }`                        | Request current lobby state |
| `join-lobby`       | `{ lobbyId, playerName, character }` | Join a lobby                |
| `chat-message-req` | `{ lobbyId, playerId, message }`     | Send message or answer      |
| `start-game`       | `{ lobbyId }`                        | Start the game (host only)  |

---

## Important Edge Cases Handled

### 1. Answering During Announcement

**Problem:** Player answers before timer starts
**Solution:** Check `lobby.activeQuestion` exists before starting timer (Line 436)

### 2. Timer Already Running

**Problem:** Player answers while timer is active
**Solution:** Clear interval before processing answer (Line 165-168)

### 3. Announcement Overlap (Client-Side)

**Problem:** New announcement while old one still showing
**Solution:** Client clears previous timeout before showing new one

### 4. Empty Lobbies

**Problem:** Lobbies remain after all players leave
**Solution:** Delete lobby when last player disconnects (Line 147-150)

---

## Configuration

### Constants You Might Want to Adjust

```typescript
// Timer duration (Line 445)
const ANSWER_TIME = 3000; // 3 seconds

// Timer update frequency (Line 446)
const TICK_INTERVAL = 100; // 100ms = 10 updates/sec

// Question display duration (Line 423)
const duration = question.split(" ").length * 500 + 1000;
// Change multiplier (500) for faster/slower reading time

// Player starting lives (Line 253)
player.lives = 3;

// Questions per player (Line 328)
const questionsNeeded = players.length * 2;
```

---

## Common Tasks

### Adding a New Socket Event

1. Add listener in `io.on("connection")` block
2. Validate lobby and player exist
3. Perform game logic
4. Emit updates to `io.to(lobbyId)`

### Modifying Timer Duration

Edit line 445: `const ANSWER_TIME = 3000;`

### Changing Questions

Edit `server/questions.json` - array of `{ id, question, answer, multiple_choice }`

### Adding New Game Round

1. Create `playRoundTwo()` function (similar to `playRoundOne`)
2. Call it after Round One completes (Line 367)
3. Update `gameState` to "roundTwo"

---

## Debugging Tips

### Enable Verbose Logging

Server already logs:

- Player joins/leaves
- Questions asked
- Answers (correct/incorrect)
- Timer events

Look for `[Server]` prefix in console

### Test Locally

1. Start server: `npm run dev` (or `node server.ts`)
2. Server runs on `http://localhost:3001`
3. Connect multiple clients to same lobby ID

### Common Issues

**Timer doesn't start:**

- Check `lobby.activeQuestion` exists
- Verify question announcement completed
- Look for early answer during announcement

**Announcements cut short:**

- Check client clears previous timeout
- Verify duration calculation is correct

**Players not seeing updates:**

- Ensure socket joined room: `socket.join(lobbyId)`
- Use `io.to(lobbyId).emit()` not `socket.emit()`

---

## File Structure

```
server/
├── server.ts           # Main server code (this file)
├── questions.json      # Question bank
├── package.json        # Dependencies
└── README.md          # This documentation
```

---

## Dependencies

- `express` - HTTP server
- `socket.io` - WebSocket communication
- `cors` - Cross-origin requests
- `@enavti/shared-types` - Shared TypeScript types between client/server

---

## Questions?

The code is organized into clear sections:

1. Setup & REST API (top)
2. Socket event handlers (middle)
3. Game logic functions (bottom)

Each function has a single responsibility and clear naming.
